1)Веб-страницы

Главная

Реализован набор функций и главную функцию, принимающую на вход строку с датой и временем в формате 
YYYY-MM-DD HH:MM:SS
 и возвращающую JSON-ответ со следующими данными:

Приветствие в формате 
"???", где ??? — «Доброе утро» / «Добрый день» / «Добрый вечер» / «Доброй ночи» в зависимости от текущего времени.
По каждой карте:
последние 4 цифры карты;
общая сумма расходов;
кешбэк (1 рубль на каждые 100 рублей).
Топ-5 транзакций по сумме платежа.
Курс валют.
Стоимость акций из S&P500.

2)Сервисы

Простой поиск

Пользователь передает строку для поиска, возвращается JSON-ответ со всеми транзакциями, содержащими запрос в описании или категории.

3)Отчеты

Траты по категории

Функция принимает на вход:

датафрейм с транзакциями,
название категории,
опциональную дату.
Если дата не передана, то берется текущая дата.

Функция возвращает траты по заданной категории за последние три месяца (от переданной даты).

"""ПОЛНОЕ ОПИСПНИЕ ВСЕХ ФУНКЦИЙ """

\\

//МОДУЛЬ UTILS//

\\


1. Импорт библиотек:

* `import json`: Импортирует модуль `json` для работы с файлами JSON.
* `import logging`: Импортирует модуль `logging` для записи логов.
* `from logging import Logger`: Импортирует класс `Logger` из модуля `logging` для создания объектов логгеров.
* `from typing import Any`: Импортирует тип `Any` из модуля `typing` для обозначения любого типа данных.
* `import pandas as pd`: Импортирует библиотеку `pandas` под псевдонимом `pd` для работы с данными в виде таблиц (DataFrame).

2. Функция `liggin()`:

* `def liggin() -> Logger:`: Определяет функцию `liggin`, которая возвращает объект класса `Logger`.
* `logging.basicConfig(...)`: Настраивает базовый конфигурацию логгера:
    * `level=logging.INFO`: Устанавливает уровень логирования на `INFO`. Это означает, что в лог будут записываться сообщения с уровнем серьезности `INFO` и выше (например, `WARNING`, `ERROR`).
    * `format="%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s"`: Определяет формат лог-сообщений.
    * `filename="utils_log.txt"`: Указывает файл, в который будут записываться логи.
    * `filemode="w"`: Устанавливает режим записи в файл "w" (запись, перезаписывая существующий файл).
* `logger = logging.getLogger(name)`: Создает объект логгера с именем `name`.
* `return logger`: Возвращает созданный объект логгера.

3. Функция `read_xlsx()`:

* `def read_xlsx(file_path: str) -> Any:`: Определяет функцию `read_xlsx`, которая принимает путь к файлу Excel (`file_path`) и возвращает данные из него в виде списка словарей.
* `transactions_df = pd.read_excel(file_path)`: Считывает файл Excel с помощью `pd.read_excel` и сохраняет результат в DataFrame `transactions_df`.
* `return transactions_df.to_dict("records")`: Преобразует DataFrame в список словарей с помощью `to_dict("records")` и возвращает его.

4. Функция `write_json()`:

* `def write_json(file_path: str, data: Any) -> None:`: Определяет функцию `write_json`, которая принимает путь к файлу JSON (`file_path`) и данные для записи (`data`).
* `with open(file_path, "w", encoding="utf-8") as f:`: Открывает файл JSON в режиме записи ("w") с кодировкой `utf-8`.
* `json.dump(data, f, indent=4, ensure_ascii=False)`: Записывает данные в файл в формате JSON с помощью `json.dump`.
    * `indent=4`: Устанавливает отступ для лучшей читаемости.
    * `ensure_ascii=False`: Предотвращает преобразование не-ASCII символов в escape-последовательности.

5. Функция `read_json()`:

* `def read_json(file_path: str) -> Any:`: Определяет функцию `read_json`, которая принимает путь к файлу JSON (`file_path`) и возвращает данные из него.
* `with open(file_path, "r", encoding="utf-8") as f:`: Открывает файл JSON в режиме чтения ("r") с кодировкой `utf-8`.
* `return json.load(f)`: Считывает данные из файла JSON с помощью `json.load` и возвращает их.

\\

//МОДУЛЬ REPORTS//

\\

**1. Импорт библиотек:**

* **`import json`:**  Импортирует модуль `json` для работы с файлами JSON.
* **`from datetime import datetime, timedelta`:** Импортирует классы `datetime` и `timedelta` из модуля `datetime` для работы с датами и временными интервалами.
* **`from typing import Any`:**  Импортирует тип `Any` из модуля `typing` для обозначения любого типа данных.
* **`import pandas as pd`:**  Импортирует библиотеку `pandas` под псевдонимом `pd` для работы с данными в виде таблиц (DataFrame).
* **`from src.utils import liggin`:** Импортирует функцию `liggin` из модуля `utils` для настройки логгера.

**2. Настройка логгера:**

* **`logger = liggin()`:** Вызывает функцию `liggin` для настройки логгера и сохраняет объект логгера в переменную `logger`.

**3. Функция `read_xlsx()`:**

* **`def read_xlsx(file_path: str) -> pd.DataFrame:`:** Определяет функцию `read_xlsx`, которая принимает путь к файлу Excel (`file_path`) и возвращает DataFrame, содержащий данные из файла.
* **`logger.info(f"Чтение данных из файла {file_path}")`:** Записывает сообщение в лог о начале чтения данных.
* **`try: ... except FileNotFoundError: ...`:** Использует блок `try-except` для обработки ошибки `FileNotFoundError`, которая возникает, если файл не найден.
    * **`return pd.read_excel(file_path)`:**  Считывает файл Excel с помощью `pd.read_excel` и возвращает полученный DataFrame.
    * **`logger.error(f"Файл {file_path} не обнаружен")`:**  Записывает сообщение об ошибке в лог.
    * **`return pd.DataFrame()`:**  Возвращает пустой DataFrame, если файл не найден.

**4. Функция `filter_by_category_date()`:**

* **`def filter_by_category_date(transactions: pd.DataFrame, category: str, start_date: str) -> Any:`:** Определяет функцию `filter_by_category_date`, которая принимает DataFrame с транзакциями, категорию и начальную дату, и возвращает отфильтрованные транзакции.
* **`end_date = datetime.strptime(start_date, "%d.%m.%Y") + timedelta(days=90)`:** Преобразует начальную дату в объект `datetime` и добавляет к ней 90 дней.
* **`filtered_transactions = transactions[ ... ]`:** Фильтрует DataFrame с помощью булевого выражения, чтобы выбрать транзакции, соответствующие заданным критериям:
    * **`transactions["category"] == category`:** Выбирает транзакции, у которых категория совпадает с заданной.
    * **`transactions["data_payment"] >= start_date`:**  Выбирает транзакции, у которых дата оплаты больше или равна заданной начальной дате.
    * **`transactions["data_payment"] < end_date.strftime("d.%m.%Y")`:**  Выбирает транзакции, у которых дата оплаты меньше заданной конечной даты (на 90 дней позже начальной).
* **`return filtered_transactions.to_dict("records")`:**  Преобразует отфильтрованный DataFrame в список словарей с помощью `to_dict("records")` и возвращает его.

**5. Функция `main_reports()`:**

* **`def main_reports() -> None:`:** Определяет функцию `main_reports`, которая является основной функцией модуля.
* **`operations = read_xlsx("../data/operations_mi.xls")`:**  Считывает данные из Excel-файла с помощью `read_xlsx` и сохраняет их в DataFrame `operations`.
* **`category = input("Напишите категорию: ")`:** Запрашивает у пользователя ввод категории.
* **`start_date = input("Напешите дату (от каторой надо считать) 3-месячного периода (например 01.01.2001): ")`:**  Запрашивает у пользователя ввод начальной даты для фильтрации.
* **`filtered_operations = filter_by_category_date(operations, category, start_date)`:**  Применяет фильтр к DataFrame `operations` с помощью функции `filter_by_category_date`.
* **`with open("reports.json", "w", encoding="utf-8") as f:`:** Открывает файл "reports.json" в режиме записи ("w") с кодировкой `utf-8`.
* **`json.dump(filtered_operations, f, indent=4, ensure_ascii=False)`:**  Записывает отфильтрованные данные в JSON-файл с помощью `json.dump`.
* **`logger.info("Отфильтрованные операции записаны сюда reports.json")`:** Записывает сообщение в лог о завершении записи данных.
* **`print("Отфильтрованные операции записаны сюда reports.json")`:**  Выводит сообщение на консоль.

**6. Блок `if __name__ == "__main__":`:**

* **`if __name__ == "__main__":`:** Этот блок кода выполняется только тогда, когда модуль запускается как главный скрипт.
* **`main_reports()`:**  Вызывает функцию `main_reports`, которая является основной функцией модуля.

\\

//МОДУЛЬ MEIN//

\\

1. Импорт модулей:

* `from src.reports import main_reports`:  Импортирует функцию `main_reports` из модуля `reports`.
* `from src.services import main_services`:  Импортирует функцию `main_services` из модуля `services`.
* `from src.views import main_views`:  Импортирует функцию `main_views` из модуля `views`.

2. Функция `main()`:

* `def main() -> None:`: Определяет функцию `main`, которая не возвращает никаких значений.
* `main_views()`: Вызывает функцию `main_views` из модуля `views`. Эта функция,отвечает за инициализацию и запуск пользовательского интерфейса (views).
* `main_reports()`:  Вызывает функцию `main_reports` из модуля `reports`. Эта функция,отвечает за обработку каких-то отчетов.
* `main_services()`: Вызывает функцию `main_services` из модуля `services`. Эта функция,отвечает за выполнение каких-то действий, связанных с вашей программой, например, запрос данных, сохранение данных, обработка каких-то операций.

3. Блок `if __name__ == "__main__":`:

* `if __name__ == "__main__":`:  Этот блок кода выполняется только тогда, когда модуль запускается как главный скрипт.
* `main()`: Вызывает функцию `main`, которая, в свою очередь, запускает функции из других модулей.

\\

//МЩДУЛЬ SERVICES//

\\

1. `get_keyword(search_t: str) -> str`: 
   - Эта функция выполняет поиск по ключевому слову (`search_t`) в описании и категории транзакций, записанных в файле Excel `operations_mi.xls`. 
   - Она возвращает JSON-строку, содержащую список найденных транзакций или сообщение об ошибке.
   - Использует библиотеку `pandas` для чтения данных из Excel и фильтрации по ключевому слову.
   -  Если транзакции не найдены, возвращает JSON с сообщением "Слово не найдено ни где".
   - Записывает результаты поиска в файл "services.json".
   - Обрабатывает ошибки `FileNotFoundError` (файл Excel не найден) и `Exception` (непредвиденные ошибки) и возвращает соответствующие JSON-ответы.

2. `get_expen_by_categ(transaction: pd.DataFrame, category: str, report_date: Optional[str] = None) -> str`:
   - Эта функция рассчитывает общие расходы по заданной категории (`category`) за последние 3 месяца от указанной даты (`report_date`).
   - Если `report_date` не указана, используется текущая дата.
   - Преобразует дату оплаты (`data_payment`) в DataFrame в формат `datetime`.
   - Фильтрует DataFrame, выбирая транзакции по категории и дате.
   - Суммирует сумму платежей (`payment_amount`) в отфильтрованном DataFrame, чтобы получить общие расходы.
   - Возвращает JSON-строку, содержащую категорию, общие расходы и дату отчета.

3. `main_services() -> None`: 
   - Эта функция является основной точкой входа в модуль `services`.
   - Она содержит примеры использования функций `get_keyword` и `get_expen_by_categ`.
   - Запрашивает у пользователя ключевое слово для поиска и дату отчета.
   - Вызывает функции `get_keyword` и `get_expen_by_categ` с полученными данными и выводит полученные JSON-ответы.

\\

//МОДУЛЬ VIEWS//

\\

Этот модуль Python представляет собой финансовое приложение, которое выполняет несколько задач, связанных с обработкой и анализом транзакций. Вот краткое описание каждой функции в модуле:

get_greet(date_time: str | None) -> str:

Принимает строку с датой и временем или None.
Возвращает приветствие в зависимости от времени суток.
calcul_total_expen(transactions_sum: List[Dict[str, Any]]) -> float:

Считает общую сумму расходов из списка транзакций.
proc_card_data(operat: List[Dict[str, Any]]) -> List[Dict[str, Any]]:

Обрабатывает данные о картах, группируя транзакции по последним четырем цифрам номера карты.
top_transactions_5(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:

Возвращает топ-5 транзакций по сумме.
get_cur_rate(currency: str) -> Any:

Получает текущий обменный курс валюты относительно рубля.
get_stoc_cur(stock: str) -> Any:

Получает информацию о текущей стоимости акций через Yahoo Finance.
main_views():

Главная функция, которая запускает все вышеупомянутые функции и сохраняет результаты в JSON-файл.
Кроме того, в модуле используются внешние библиотеки, такие как requests для HTTP-запросов и yfinance для получения данных о фондовом рынке. Также присутствует интеграция с .env файлом для безопасного хранения API ключа.

Модуль предполагает использование вспомогательных функций из src.utils, таких как read_json, read_xlsx, и write_json, для чтения и записи данных. Эти функции должны быть определены в другом месте вашего проекта.

\\

//МОДУЛЬ TEST_REPORTS//

\\

**1. Импорты:**

* **`import unittest`:** Импортирует модуль `unittest` для создания тестовых случаев.
* **`from io import StringIO`:** Импортирует класс `StringIO` для имитации ввода с клавиатуры.
* **`from typing import Any`:**  Импортирует тип `Any` из модуля `typing` для обозначения любого типа данных.
* **`from unittest.mock import mock_open, patch`:**  Импортирует декораторы `mock_open` и `patch` из модуля `unittest.mock` для имитации открытия файлов и замены функций.
* **`import pandas as pd`:**  Импортирует библиотеку `pandas` под псевдонимом `pd` для работы с данными в виде таблиц (DataFrame).
* **`from src.reports import main_reports, read_xlsx`:**  Импортирует функции `main_reports` и `read_xlsx` из модуля `reports` для тестирования.


**2. Класс `TestReadTransactionsXlsx`:**
    - Этот класс содержит тесты для функции `read_xlsx`.
    - **`@patch("pandas.read_excel")`:**  Декоратор `patch` имитирует функцию `pd.read_excel`, заменяя ее на моковую функцию. 
    - **`test_read_transactions_xlsx_success`:**  Этот тест проверяет успешное чтение файла Excel. 
        - Он создает моковый DataFrame и устанавливает его как возвращаемое значение моковой функции `pd.read_excel`. 
        - Вызывает `read_xlsx` с тестовым путем к файлу.
        -  Использует `pd.testing.assert_frame_equal` для сравнения результата с моковым DataFrame.
    - **`test_read_transactions_xlsx_failure`:**  Этот тест проверяет обработку ошибки `FileNotFoundError`, которая возникает, если файл не найден.
        - Он устанавливает `side_effect` для моковой функции `pd.read_excel` равным `FileNotFoundError`.
        - Вызывает `read_xlsx` с тестовым путем к файлу, который не существует.
        - Проверяет, что результат является пустым DataFrame (`self.assertTrue(result.empty)`).


**3. Класс `TestMainReports`:**
    - Этот класс содержит тесты для функции `main_reports`.
    - **`@patch("builtins.open", new_callable=mock_open)`:**  Декоратор `patch` имитирует функцию `open` для открытия файлов, заменяя ее на моковую функцию.
    - **`@patch("src.reports.filter_transactions_by_category_and_date")`:**  Декоратор `patch` имитирует функцию `filter_transactions_by_category_and_date` (вероятно, не показана в вашем коде), заменяя ее на моковую функцию. 
    - **`@patch("src.reports.read_transactions_xlsx")`:**  Декоратор `patch` имитирует функцию `read_transactions_xlsx`, заменяя ее на моковую функцию. 
    - **`@patch("sys.stdin", StringIO("Еда\n01.01.2020\n"))`:**  Декоратор `patch` имитирует ввод с клавиатуры (`sys.stdin`), заменяя его на строку, которая будет введена в качестве "категории" и "даты".
    - **`test_main_reports`:**  Этот тест проверяет выполнение функции `main_reports`.
        - Он создает моковый DataFrame и устанавливает его как возвращаемое значение моковой функции `read_transactions_xlsx`. 
        - Устанавливает возвращаемое значение моковой функции `filter_transactions_by_category_and_date` как пустой список.
        - Вызывает `main_reports`. 
        - Проверяет, что `read_transactions_xlsx` и `filter_transactions_by_category_and_date` вызывались с ожидаемыми аргументами (`assert_called_once_with`).

**4. Блок `if __name__ == "__main__":`:**
    - Этот блок кода выполняется только тогда, когда модуль запускается как главный скрипт.
    - **`unittest.main()`:**  Запускает тесты, определенные в этом модуле.

\\

//МОДУЛЬ TEST_SERVICES//

\\

Импорты:

json, unittest, typing.Any, и unittest.mock.patch используются для тестирования и мокирования.
pandas используется для работы с данными в формате DataFrame.
pytest.fixture предоставляет механизм для настройки тестового окружения.
get_keyword — это функция, которую необходимо протестировать.
Тестовые функции:

test_search_term_in_description и test_search_term_in_category проверяют, что функция get_keyword возвращает правильный JSON, если ключевое слово найдено в описании или категории соответственно.
test_file_not_found_error и test_other_exceptions проверяют обработку исключений, таких как FileNotFoundError и другие.
Фикстура mock_read_excel:

Имитирует функцию pandas.read_excel, возвращая DataFrame из заранее определенных данных.
Функция test_get_transactions_by_keyword:

Проверяет, что функция get_transactions_by_keyword возвращает правильный JSON с результатами поиска.
Класс TestGetTransactionsByKeyword:

Содержит тесты, которые проверяют корректность обработки исключений функцией get_transactions_by_keyword.
Блок if __name__ == "__main__":

Запускает все тесты в модуле, если файл выполняется как основная программа.

\\

//МОДУЛЬ TEST_VIEWS//

\\

Импорты:

unittest и pytest используются для написания и параметризации тестов.
typing.Any и unittest.mock.Mock, patch применяются для создания моков и заглушек.
pandas используется для работы с данными.
Импортируются функции из модуля src.views, которые будут тестироваться.
Тестирование функции приветствия:

test_get_greeting использует декоратор pytest.mark.parametrize для проверки корректности возвращаемого приветствия в зависимости от времени суток.
Мокирование запросов к API:

mocked_requests_get создает моковый ответ для функции requests.get, имитируя ответ API с курсом валют.
Тестовый класс TestFunctions:

Содержит методы для тестирования различных функций из модуля src.views.
setUp используется для настройки перед каждым тестом.
test_get_stock_currency проверяет функцию получения курса акций.
test_calculate_total_expenses проверяет подсчет общих расходов.
test_read_transactions_xlsx проверяет чтение транзакций из файла Excel.
test_empty_operations и test_single_card_transaction тестируют обработку данных по карточным операциям.
test_top_transactions проверяет функцию выбора топ-транзакций.
Функция test_process_card_data:

Проверяет обработку данных по карточным операциям, включая расчет кэшбэка и общих расходов.
Блок if __name__ == "__main__":

Запускает все тесты в модуле, если файл выполняется как основная программа.